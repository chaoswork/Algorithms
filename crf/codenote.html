<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>CRF原理及代码实现</title>
<!-- 2018-01-03 三 11:48 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Chao Huang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="./css/worg.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">CRF原理及代码实现</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 一些说明</a></li>
<li><a href="#sec-2">2. 流程</a>
<ul>
<li><a href="#sec-2-1">2.1. main -&gt; crf_learn</a></li>
<li><a href="#sec-2-2">2.2. encoder.learn (encoder.cpp:240)</a></li>
<li><a href="#sec-2-3">2.3. runCRF(encoder.cpp:148)</a>
<ul>
<li><a href="#sec-2-3-1">2.3.1. x[i].gradient(tagger.cpp:309)</a></li>
</ul>
</li>
<li><a href="#sec-2-4">2.4. 预测</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 一些说明</h2>
<div class="outline-text-2" id="text-1">
<ol class="org-ol">
<li>crfpp的训练样本是通过空行分割的下文叫做 <b>样本段落</b> ，其实就是sentences
</li>
<li>crfpp开辟了一个全局的alpha数组来存储特征函数的参数
</li>
<li>crfpp开辟了一个全局的excepted数组来存放梯度
</li>
<li>feature_index所有的段落都用同一个，里面不仅存放了模版，还存放了所有出现过的特征feature_cache_
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 流程</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> main -&gt; crf_learn</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>设置参数
</li>
<li>定义 <code>Encoder encoder</code>
</li>
<li><code>encoder.learn</code>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> encoder.learn (encoder.cpp:240)</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>定义 <code>EncoderFeatureIndex feature_index;</code>
</li>
<li>定义 <code>std::vector&lt;TaggerImpl* &gt; x;</code>
</li>
<li>加载模版文件和训练样本,本次加载实现两个功能
<ul class="org-ul">
<li>代码如下
<div class="org-src-container">

<pre class="src src-cpp">CHECK_FALSE(feature_index.open(templfile, trainfile))
    &lt;&lt; feature_index.what();
</pre>
</div>
</li>
<li>存储模版到 <code>feature_index.unigram_templs_和feature_index.bigram_templs_</code>
</li>
<li>统计label的集合到 <code>feature_index.y_</code>
<ul class="org-ul">
<li><code>feature_index.y_</code> 是个vector&lt;char*&gt;
</li>
<li>后面会有用到 <code>feature_index.y(i)</code> 这个函数，就是返回第i个label
</li>
<li><code>feature_index.xsize=len(cols) - 1</code> 的值为段落列数减1
</li>
</ul>
</li>
</ul>
</li>
<li>第二次加载训练样本
<ul class="org-ul">
<li>每个 <b>样本段落</b> 定义一个临时的 <code>TaggerImpl *_x = new TaggerImpl();</code>
</li>
<li><code>_x-&gt;open(&amp;feature_index)</code> 
<ul class="org-ul">
<li><code>_x.feature_index_ = feature_index</code> 所有的_x都使用同一个feature_index
</li>
<li><code>model = LEARN</code>
</li>
<li><code>_x.ysize_ = feature_index.ysize()</code> 也就是label的个数
</li>
</ul>
</li>
<li><code>_x-&gt;read(ifs)</code>
<ul class="org-ul">
<li>代码如下
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #5FD7FF; font-style: italic;">bool</span> <span style="color: #AF87FF;">TaggerImpl</span>::<span style="color: #87D700;">read</span>(<span style="color: #AF87FF;">std</span>::<span style="color: #5FD7FF; font-style: italic;">istream</span> *<span style="color: #FF8C00;">is</span>) {
  <span style="color: #5FD7FF; font-style: italic;">char</span> <span style="color: #FF8C00;">line</span>[8192];
  clear();

  <span style="color: #FF1493;">for</span> (;;) {
    <span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>is-&gt;getline(line, <span style="color: #FF1493;">sizeof</span>(line))) {
      is-&gt;clear(<span style="color: #AF87FF;">std</span>::<span style="color: #AF87FF;">ios</span>::eofbit|<span style="color: #AF87FF;">std</span>::<span style="color: #AF87FF;">ios</span>::badbit);
      <span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">true</span>;
    }
    <span style="color: #FF1493;">if</span> (line[0] == <span style="color: #CDC673;">'\0'</span> || line[0] == <span style="color: #CDC673;">' '</span> || line[0] == <span style="color: #CDC673;">'\t'</span>) <span style="color: #FF1493;">break</span>;
    <span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>add(line)) <span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">false</span>;
  }

  <span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">true</span>;
}
</pre>
</div>
</li>
<li>ifs是一个文件流，_x一次读取样本文件的一个段落
</li>
<li>将段落存储到 <code>_x.x_</code> 中
<ul class="org-ul">
<li><code>_x.x_</code> 是个二维数组，假设一个段落为
<pre class="example">
我    a    A
爱    b    B
百度  d    D
</pre>
</li>
<li>则 <code>_x.x_</code> 为：
<div class="org-src-container">

<pre class="src src-cpp">x_[0] = <span style="color: #5FD7FF; font-style: italic;">vecotr</span>&lt;<span style="color: #5FD7FF; font-style: italic;">char</span>*&gt;(<span style="color: #CDC673;">'&#25105;'</span>, <span style="color: #CDC673;">'a'</span>, <span style="color: #CDC673;">'A'</span>)
x_[1] = <span style="color: #5FD7FF; font-style: italic;">vector</span>&lt;<span style="color: #5FD7FF; font-style: italic;">char</span>*&gt;(<span style="color: #CDC673;">'&#29233;'</span>, <span style="color: #CDC673;">'b'</span>, <span style="color: #CDC673;">'B'</span>)
x_[2] = <span style="color: #5FD7FF; font-style: italic;">vector</span>&lt;<span style="color: #5FD7FF; font-style: italic;">char</span>*&gt;(<span style="color: #CDC673;">'&#30334;&#24230;'</span>, <span style="color: #CDC673;">'d'</span>, <span style="color: #CDC673;">'D'</span>)
</pre>
</div>
</li>
</ul>
</li>
<li>然后遍历 <code>feature_index.y_</code>, 得到label的下标
</li>
<li><code>_x.answer_[s]=index(labels);</code>  
<ul class="org-ul">
<li><code>_x.answer_</code> 和 <code>_x.x_</code> 下标一一对应
</li>
<li>answer存储的是label的下标
</li>
</ul>
</li>
<li><code>_x.result_[s]=0</code>
</li>
<li><code>_x.node_[s].resize(ysize)</code> node的类型是 <code>std::vector&lt;std::vector &lt;Node *&gt; &gt;</code>
</li>
</ul>
</li>
<li><code>_x-&gt;shrink()</code>
<ul class="org-ul">
<li>每个样本段落根据特征模版来生成特征，调用 <code>_x.feature_index.buildFeatures(this)</code> 函数
<ul class="org-ul">
<li>代码如下
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">ADD</span> { <span style="color: #5FD7FF; font-style: italic;">int</span> <span style="color: #FF8C00;">id</span> = <span style="color: #FF1493;">this</span>-&gt;getID(os.c_str());         \
    <span style="color: #FF1493;">if</span> (id != -1) feature.push_back(id); } <span style="color: #FF1493;">while</span> (0)

<span style="color: #5FD7FF; font-style: italic;">bool</span> <span style="color: #AF87FF;">FeatureIndex</span>::<span style="color: #87D700;">buildFeatures</span>(<span style="color: #5FD7FF; font-style: italic;">TaggerImpl</span> *<span style="color: #FF8C00;">tagger</span>) {
  <span style="color: #5FD7FF; font-style: italic;">string_buffer</span> <span style="color: #FF8C00;">os</span>;
  <span style="color: #AF87FF;">std</span>::<span style="color: #5FD7FF; font-style: italic;">vector</span> &lt;<span style="color: #5FD7FF; font-style: italic;">int</span>&gt; <span style="color: #FF8C00;">feature</span>;

  tagger-&gt;set_feature_id(feature_cache_.size());

  <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">size_t</span> <span style="color: #FF8C00;">cur</span> = 0; cur &lt; tagger-&gt;size(); ++cur) {
    <span style="color: #FF1493;">for</span> (<span style="color: #AF87FF;">std</span>::<span style="color: #AF87FF;">vector</span>&lt;<span style="color: #5FD7FF; font-style: italic;">char</span> *&gt;::<span style="color: #5FD7FF; font-style: italic;">const_iterator</span> <span style="color: #FF8C00;">it</span> = unigram_templs_.begin();
         it != unigram_templs_.end(); ++it) {
      CHECK_FALSE(apply_rule(&amp;os, *it, cur, *tagger))
          &lt;&lt; <span style="color: #CDC673;">" format error: "</span> &lt;&lt; *it;
      ADD;
    }
    feature_cache_.add(feature);
    feature.clear();
  }

  <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">size_t</span> <span style="color: #FF8C00;">cur</span> = 1; cur &lt; tagger-&gt;size(); ++cur) {
    <span style="color: #FF1493;">for</span> (<span style="color: #AF87FF;">std</span>::<span style="color: #AF87FF;">vector</span>&lt;<span style="color: #5FD7FF; font-style: italic;">char</span> *&gt;::<span style="color: #5FD7FF; font-style: italic;">const_iterator</span> <span style="color: #FF8C00;">it</span> = bigram_templs_.begin();
         it != bigram_templs_.end(); ++it) {
      CHECK_FALSE(apply_rule(&amp;os, *it, cur, *tagger))
          &lt;&lt; <span style="color: #CDC673;">"format error: "</span> &lt;&lt; *it;
      ADD;
    }
    feature_cache_.add(feature);
    feature.clear();
  }

  <span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">true</span>;
}
<span style="color: #FF1493;">#undef</span> ADD
}
</pre>
</div>
</li>
</ul>
</li>
<li><code>_x.set_feature_id(_x.feature_index_.feature_cache_.size())</code> // 设置feature_id
</li>
<li>遍历 <code>_x.feature_index_.unigram_templs</code>
<ul class="org-ul">
<li><code>_x.feature_index_.apply_rule</code> 是将每个模版解析为固定的特征
<pre class="example">
我    a    A
爱    b    B &lt;= current token
百度  d    D

U01:%x[-1,1] 就解析成 U01a
因为[-1,1]对应着a这个字段
U02:%x[-1,1]/%[1,0] -&gt; U02a/百度
</pre>
</li>
<li>根据模版解析出来的特征存储到os对象中
</li>
<li><code>id = _x.feature_index_.getID(os.c_str())</code> ,作用是给解析出来的特征全局编号，如果有则直接取出，如果没有，则新建编号
<ul class="org-ul">
<li>这个id不是随便给的，而是一个特征，就占据label个数大小的空间，id就是起始位置。所以对于alpha，alpha[id + node-&gt;y]就是y=node-&gt;y时，该特征的alpha值
</li>
</ul>
</li>
<li>注意这里是对_x.x_中的每一行都进行解析，每一行解析完后会得到一个feature_id的vector，存储到 <code>_x.feature_index_.feature_cache_</code> 这个vector中。
</li>
<li>需要注意的是，每一个 <code>_x.feature_index_</code> 都指向同一个对象，所以，feature_cache_最终是一个存储了每一行，应用特征模版解析出特征后，其特征编号的vector
</li>
<li>那对应每个段落如何区分？这就是前面 <code>_x.set_feature_id</code> 的作用，每个 <code>_x</code> 会根据当前feature_cache_.size()的大小保存一个feature_id
</li>
</ul>
</li>
<li>遍历 <code>_x.feature_index_.bigram_templs</code>
<ul class="org-ul">
<li>同unigram
</li>
</ul>
</li>
<li>完成后，对 <code>_x.x_, _x.result_, _x.node_, _x.answer_</code> 利用swap执行了一个内存从新分配的动作
</li>
</ul>
</li>

<li><code>_x.set_thread_id()</code> , 分配线程id
</li>
</ul>
</li>

<li>这个时候，最开始定义的x会执行 <code>x.push_back(_x)</code>
</li>
<li>全局唯一的 <code>feature_index.shrink(freq)</code> 会根据特征出现频次进行筛选
</li>
<li>最终，会根据设置的参数，执行 <code>runCRF(x, &amp;feature_index, &amp;alpha[0], maxitr, C, eta, shrinking_size, thread_num, true)</code>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> runCRF(encoder.cpp:148)</h3>
<div class="outline-text-3" id="text-2-3">
<ol class="org-ol">
<li>进行了一些多线程的设置
</li>
<li>线程中，执行了 <code>x[i]-&gt;gradient(&amp;expected[0])</code>
</li>
<li>代码如下
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #5FD7FF; font-style: italic;">void</span> <span style="color: #87D700;">run</span>() {
  obj = 0.0;
  err = zeroone = 0;
  <span style="color: #AF87FF;">std</span>::fill(expected.begin(), expected.end(), 0.0);
  <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">size_t</span> <span style="color: #FF8C00;">i</span> = start_i; i &lt; size; i += thread_num) {
    obj += x[i]-&gt;gradient(&amp;expected[0]);
    <span style="color: #5FD7FF; font-style: italic;">int</span> <span style="color: #FF8C00;">error_num</span> = x[i]-&gt;eval();
    err += error_num;
    <span style="color: #FF1493;">if</span> (error_num) ++zeroone;
  }
}
</pre>
</div>
</li>
<li>start_i是线程index，每个线程处理start_i + k*thread_num位置的x
</li>
<li>eval是统计answer和result的不同个数。
</li>
<li>obj就是损失函数
</li>
<li>expect是梯度向量
</li>
</ol>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><span class="section-number-4">2.3.1</span> x[i].gradient(tagger.cpp:309)</h4>
<div class="outline-text-4" id="text-2-3-1">
<ol class="org-ol">
<li>feature_index.size()=unigram特征数x状态数+bigram特征数*状态数*状态数，并且把这个数量设置为alpha的数量
</li>
</ol>
</div>


<ol class="org-ol"><li><a id="sec-2-3-1-1" name="sec-2-3-1-1"></a>x[i].buildLattice<br  /><div class="outline-text-5" id="text-2-3-1-1">
<ol class="org-ol">
<li>feature_index.rebuildFeatures(this)
<ul class="org-ul">
<li>获取feature_id
</li>
<li>根据feature_id从feature_cache_中获取段落的特征编号
</li>
<li>rebuild的作用就是遍历段落的每一行，构建网格
<img src="./images/node.png" alt="node.png" />
</li>
<li>节点对应这unigram，边对应着bigram
</li>
<li>似乎所有的边对应的特征都是一个，B
</li>
<li>每个Node都有两个vector,lpath和rpath,分别指向对应的路径
</li>
</ul>
</li>
<li>对所有node执行feature_index_-&gt;calcCost(Node[i][j])
<ul class="org-ul">
<li>代码如下
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #5FD7FF; font-style: italic;">void</span> <span style="color: #AF87FF;">FeatureIndex</span>::<span style="color: #87D700;">calcCost</span>(<span style="color: #5FD7FF; font-style: italic;">Node</span> *<span style="color: #FF8C00;">n</span>) {
  n-&gt;cost = 0.0;

<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">ADD_COST</span>(<span style="color: #FF8C00;">T</span>, <span style="color: #FF8C00;">A</span>)                                                  \
  { <span style="color: #5FD7FF; font-style: italic;">T</span> <span style="color: #FF8C00;">c</span> = 0;                                                            \
    <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">int</span> *<span style="color: #FF8C00;">f</span> = n-&gt;fvector; *f != -1; ++f) c += (A)[*f + n-&gt;y];       \
    n-&gt;cost =cost_factor_ *(<span style="color: #5FD7FF; font-style: italic;">T</span>)c; }

  <span style="color: #FF1493;">if</span> (alpha_float_) ADD_COST(<span style="color: #5FD7FF; font-style: italic;">float</span>,  alpha_float_)
    <span style="color: #FF1493;">else</span>             ADD_COST(<span style="color: #5FD7FF; font-style: italic;">double</span>, alpha_);
<span style="color: #FF1493;">#undef</span> ADD_COST

}
</pre>
</div>
</li>
<li>这里需要理解为什么 <code>c += alpha[*f + n-&gt;y];</code>
</li>
<li><code>*f</code> 就是特征的编号，但是这个编号有个trick，如果这个特征是unigram，那么下一个编号是 <code>cur+len(label)</code> ,如果是bigram，那么下一个编号为 <code>cur+len(label)^2</code>
</li>
<li>所以 <code>*f + n-&gt;y</code> 就对应alpha预留出的空间
<ul class="org-ul">
<li>Node对应unigram，Node.cost就对应y=y<sub>i</sub>时的 \(\sum_{i,k}\mu_{k}s_{k}(y_{i},x,i)\) , <code>alpha[*f + n-&gt;y]</code> 就是 \(\mu_{k}\)
</li>
</ul>
</li>
</ul>
</li>
<li>对所有的边执行feature_index_-&gt;calcCost(Path)
<ul class="org-ul">
<li>代码如下
<div class="org-src-container">

<pre class="src src-cpp">p-&gt;cost = 0.0;

<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">ADD_COST</span>(<span style="color: #FF8C00;">T</span>, <span style="color: #FF8C00;">A</span>)                                          \
  { <span style="color: #5FD7FF; font-style: italic;">T</span> <span style="color: #FF8C00;">c</span> = 0.0;                                                  \
    <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">int</span> *<span style="color: #FF8C00;">f</span> = p-&gt;fvector; *f != -1; ++f)                    \
      c += (A)[*f + p-&gt;lnode-&gt;y * y_.size() + p-&gt;rnode-&gt;y];     \
    p-&gt;cost =cost_factor_*(<span style="color: #5FD7FF; font-style: italic;">T</span>)c; }

  <span style="color: #FF1493;">if</span> (alpha_float_) ADD_COST(<span style="color: #5FD7FF; font-style: italic;">float</span>,  alpha_float_)
    <span style="color: #FF1493;">else</span>             ADD_COST(<span style="color: #5FD7FF; font-style: italic;">double</span>, alpha_);
}
<span style="color: #FF1493;">#undef</span> ADD_COST
</pre>
</div>
</li>
<li>这里 <code>c += alpha[*f + p-&gt;lnode-&gt;y * y_.size() + p-&gt;rnode-&gt;y];</code>
<ul class="org-ul">
<li>其实这里的p-&gt;fvector就只有一个值，B的下标,所以 <code>*f</code> 后面共有len(label)^2个值，对应着边
</li>
<li>path是bigram, path.cost就对应y<sub>i-1</sub>和y<sub>i</sub>两个值固定时的 \(\sum_{i,k}\lambda_{k}t_{k}(y_{i-1}, y_{i},x,i)\) , <code>alpha[*f + p-&gt;lnode-&gt;y * y_.size() + p-&gt;rnode-&gt;y]</code> 对应\(\lambda_{k}\)
</li>
<li>图上看上去远大于len(label)^2条边，其实Path(Node[i-1,j],Node[i,k])和Path(Node[i,j],Node[i+1,k])可以认为是一个函数，故可以认为是一样的边
</li>
<li>刚开始alpha都是0，但是由于设置了迭代次数，后面alpha的值会通过 <code>lbfgs.optimize</code> 进行改变，然后每次迭代都执行gradient
</li>
</ul>
</li>
</ul>
</li>
<li>addCost操作就是把每个节点和边上的cost值设置为函数参数相加,就对应着M矩阵的值
</li>
</ol>
</div>
</li>

<li><a id="sec-2-3-1-2" name="sec-2-3-1-2"></a>x[i].forwordbackword<br  /><div class="outline-text-5" id="text-2-3-1-2">
<ul class="org-ul">
<li>从前往后遍历每一个Node，调用Node[i][j]-&gt;calcAlpha
<ul class="org-ul">
<li>代码如下
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #5FD7FF; font-style: italic;">void</span> <span style="color: #AF87FF;">Node</span>::<span style="color: #87D700;">calcAlpha</span>() {
  alpha = 0.0;
  <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">const_Path_iterator</span> <span style="color: #FF8C00;">it</span> = lpath.begin(); it != lpath.end(); ++it)
    alpha = logsumexp(alpha,
                      (*it)-&gt;cost +(*it)-&gt;lnode-&gt;alpha,
                      (it == lpath.begin()));
  alpha += cost;
}
</pre>
</div>
</li>
<li>exp(Node[i][j].cost)是y<sub>i</sub>=j时的观测概率，Node的所cost，就类似HMM的状态概率矩阵
</li>
<li>exp(path[p][q].cost)是y<sub>i-1</sub>=p,y<sub>i</sub>=q的转移概率，类似HMM中的转移概率矩阵
</li>
<li>定义M[p][q]=exp(Node[i][q])*exp(Path[p][q]),就相当于从状态p到状态q的概率。
</li>
<li>定义 \(\alpha_{i}[j]\) 为i位置，y<sub>i</sub>=j的前向概率
<ul class="org-ul">
<li>计算如图所示
</li>
<li><img src="./images/alpha.png" alt="alpha.png" />
</li>
<li></li>
</ul>
</li>
<li>这里又有一个trick。每个节点保存的Node[i][j].alpha=log(&alpha;)
<ul class="org-ul">
<li>这样做的原因猜测是为了方便计算，因为看上图乘的概率都是exp格式的，用exp表示可以方便转化成加法
</li>
<li>用 \(\alpha\) 的时候，采用exp(Node[i][j].alpha)即可
</li>
</ul>
</li>
<li>logsumexp(x,y)这个函数是计算 \(log(e^{x} + e^{y})\)
<ul class="org-ul">
<li>logsumexp(logsumexp(x,y),z) = \(log(e^{x} + e^{y} + e^{z})\)
</li>
<li>(*it)-&gt;cost是边的转义概率
</li>
<li>(*it)-&gt;lnode-&gt;alpha就是lpath对应节点的alpha
</li>
<li>cost是当前节点状态概率
</li>
</ul>
</li>
<li>以 \(Node[1][3]\) 节点为例，解释上面的代码
<div class="org-src-container">

<pre class="src src-cpp">Node[1][3].alpha = log(exp(Node[0][0].alpha)*exp(Path[0][3].cost)*exp(Node[1][3].cost) + \
                      exp(Node[0][1].alpha)*exp(Path[1][3].cost)*exp(Node[1][3].cost) + \
                      exp(Node[0][2].alpha)*exp(Path[2][3].cost)*exp(Node[1][3].cost) + \
                      exp(Node[0][3].alpha)*exp(Path[3][4].cost)*exp(Node[1][3].cost))
                 = log(exp(Node[0][0].alpha + Path[0][3].cost + Node[1][3].cost) + \
                       exp(Node[0][1].alpha + Path[1][3].cost + Node[1][3].cost) + \
                       exp(Node[0][2].alpha + Path[2][3].cost + Node[1][3].cost) + \
                       exp(Node[0][3].alpha + Path[3][3].cost + Node[1][3].cost))
                 = log(exp(Node[0][0].alpha + Path[0][3].cost) + \
                       exp(Node[0][1].alpha + Path[1][3].cost) + \
                       exp(Node[0][2].alpha + Path[2][3].cost) + \
                       exp(Node[0][3].alpha + Path[3][3].cost)) + Node[1][3].cost
</pre>
</div>
</li>

<li>\(Node[1][3].cost\) 可以提取出来的原因是
<ul class="org-ul">
<li>a = log(e<sup>x+k</sup> + e<sup>y+k</sup>)
</li>
<li>e<sup>a</sup> = e<sup>x+k</sup> + e<sup>y+k</sup>
</li>
<li>e<sup>a</sup>e<sup>-k</sup> = e<sup>x+k</sup>e<sup>-k</sup> + e<sup>y+k</sup>e<sup>-k</sup>
</li>
<li>e<sup>a-k</sup> = e<sup>x</sup> + e<sup>y</sup>
</li>
<li>a - k = log(e<sup>x</sup> + e<sup>y</sup>)
</li>
<li>a = log(e<sup>x</sup> + e<sup>y</sup>) + k
</li>
</ul>
</li>
</ul>
</li>
<li>从后往前遍历，calcBeta
<ul class="org-ul">
<li>代码如下
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #5FD7FF; font-style: italic;">void</span> <span style="color: #AF87FF;">Node</span>::<span style="color: #87D700;">calcBeta</span>() {
  beta = 0.0;
  <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">const_Path_iterator</span> <span style="color: #FF8C00;">it</span> = rpath.begin(); it != rpath.end(); ++it)
    beta = logsumexp(beta,
                     (*it)-&gt;cost +(*it)-&gt;rnode-&gt;beta,
                     (it == rpath.begin()));
  beta += cost; <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#36825;&#37324;&#20026;&#20160;&#20040;&#35201;&#25191;&#30528;&#30340;&#21152;&#20010;cost??? &#22240;&#20026;&#20026;&#20102;&#36882;&#25512;&#20844;&#24335;</span>
</pre>
</div>
</li>
<li>calcBeta和calcAlpha从代码上看是十分类似的。网上很多文章对calcBeta都是说了一句和calcAlpha类似就不讲了。但是这里隐藏着一个陷阱。
</li>
<li>假设以 \(Node[2][1].beta\) 为例
<div class="org-src-container">

<pre class="src src-cpp">Node[2][1].beta = log(exp(Node[3][0].beta)*exp(Path[1][0].cost)*exp(Node[3][0].cost) + \
                      exp(Node[3][1].beta)*exp(Path[1][1].cost)*exp(Node[3][1].cost) + \
                      exp(Node[3][2].beta)*exp(Path[1][2].cost)*exp(Node[3][2].cost) + \
                      exp(Node[3][3].beta)*exp(Path[1][3].cost)*exp(Node[3][3].cost))
                 = log(exp(Node[3][0].beta + Path[1][0].cost + Node[3][0].cost) + \
                       exp(Node[3][1].beta + Path[1][1].cost + Node[3][1].cost) + \
                       exp(Node[3][2].beta + Path[1][2].cost + Node[3][2].cost) + \
                       exp(Node[3][3].beta + Path[1][3].cost + Node[3][3].cost))
</pre>
</div>
</li>
<li>这里明显可以看出，有个cost根本提不出来
</li>
<li>这其实是作者的又一个trick，作者让 \(Node[i][j].beta_{new}=Node[i][j].beta+Node[i][j].cost\)
</li>
<li>将上面的 \(Node[2][1].beta\) 带入，得到
<div class="org-src-container">

<pre class="src src-cpp">Node[2][1].beta_new = Node[2][1].beta + Note[2][1].cost
                    = log(exp(Node[3][0].beta_new + Path[1][0].cost) + \
                          exp(Node[3][1].beta_new + Path[1][1].cost) + \
                          exp(Node[3][2].beta_new + Path[1][2].cost) + \
                          exp(Node[3][3].beta_new + Path[1][3].cost)) + Node[2][1].cost
</pre>
</div>
</li>
<li>所以说，\(Node[2][1].beta - Node[2][1].cost\) 才真正对应着公式中的 &beta;,一定要牢记这一点，不然后面还有很多坑要踩。
</li>
<li>\alpha和\beta的区别
<ul class="org-ul">
<li>\alpha是，到时刻t，观测为x<sub>1</sub>,x<sub>2</sub>,&#x2026;,x<sub>t</sub>的条件下，该时刻状态为y<sub>i</sub>的概率。P(y<sub>t</sub>|x<sub>1:t</sub>)
</li>

<li>\beta是，到t时刻，该时刻状态为y<sub>i</sub>的条件下，后续观测为x<sub>t+1</sub>,x<sub>t+2</sub>,..,x<sub>T</sub>的概率,P(x<sub>t+1:T</sub>|y<sub>t</sub>)
</li>
</ul>
</li>
</ul>
</li>

<li>最后计算Z
<ul class="org-ul">
<li>Z使用Beta计算的
<div class="org-src-container">

<pre class="src src-cpp">Z_ = 0.0;
<span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">size_t</span> <span style="color: #FF8C00;">j</span> = 0; j &lt; ysize_; ++j)
  Z_ = logsumexp(Z_, node_[0][j]-&gt;beta, j == 0);
</pre>
</div>
</li>
<li>按理说, Z也包含了 &beta; 多余的cost, 难道是因为Z值固定，所以就不care了？
</li>
</ul>
</li>
</ul>
</div>
</li>

<li><a id="sec-2-3-1-3" name="sec-2-3-1-3"></a>遍历Node，执行Node[i][j]-&gt;calcExpectation(expected, Z_, ysize_);<br  /><div class="outline-text-5" id="text-2-3-1-3">
<ol class="org-ol">
<li>代码如下
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #5FD7FF; font-style: italic;">void</span> <span style="color: #AF87FF;">Node</span>::<span style="color: #87D700;">calcExpectation</span>(<span style="color: #5FD7FF; font-style: italic;">double</span> *<span style="color: #FF8C00;">expected</span>, <span style="color: #5FD7FF; font-style: italic;">double</span> <span style="color: #FF8C00;">Z</span>, <span style="color: #5FD7FF; font-style: italic;">size_t</span> <span style="color: #FF8C00;">size</span>) <span style="color: #FF1493;">const</span> {
  <span style="color: #FF1493;">const</span> <span style="color: #5FD7FF; font-style: italic;">double</span> <span style="color: #FF8C00;">c</span> = <span style="color: #AF87FF;">std</span>::exp(alpha + beta - cost - Z);
  <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">int</span> *<span style="color: #FF8C00;">f</span> = fvector; *f != -1; ++f) expected[*f + y] += c;
  <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">const_Path_iterator</span> <span style="color: #FF8C00;">it</span> = lpath.begin(); it != lpath.end(); ++it)
    (*it)-&gt;calcExpectation(expected, Z, size);
}
</pre>
</div>
</li>
<li>这里的c对应公式
<ul class="org-ul">
<li>$$P(Y_{i}=y_{i}|x)=\frac{\alpha_{i}^{T}(y_{i}|x)\beta_{i}(y_{i}|x)}{Z(x)}$$
</li>
<li>可以看到，代码是 <code>exp(alpha + beta - cost -Z)</code> ,这里用的是 <code>beta - cost</code>
</li>
</ul>
</li>
<li>expected的下标格式和全局alpha数组的一样
<ul class="org-ul">
<li>由于c是当前节点位置y=node.y的条件概率
</li>
<li>命中特征是f为1，故 <code>expected[*f+y]</code> 存储的就是状态特征函数s(y=node.y,x,i)的期望
</li>
</ul>
</li>
<li>然后对被一条边求期望，也就是转移特征函数的期望
<ul class="org-ul">
<li>代码如下
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #5FD7FF; font-style: italic;">void</span> <span style="color: #AF87FF;">Path</span>::<span style="color: #87D700;">calcExpectation</span>(<span style="color: #5FD7FF; font-style: italic;">double</span> *<span style="color: #FF8C00;">expected</span>, <span style="color: #5FD7FF; font-style: italic;">double</span> <span style="color: #FF8C00;">Z</span>, <span style="color: #5FD7FF; font-style: italic;">size_t</span> <span style="color: #FF8C00;">size</span>) <span style="color: #FF1493;">const</span> {
  <span style="color: #FF1493;">const</span> <span style="color: #5FD7FF; font-style: italic;">double</span> <span style="color: #FF8C00;">c</span> = <span style="color: #AF87FF;">std</span>::exp(lnode-&gt;alpha + cost + rnode-&gt;beta - Z);
  <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">int</span> *<span style="color: #FF8C00;">f</span> = fvector; *f != -1; ++f)
    expected[*f + lnode-&gt;y * size + rnode-&gt;y] += c;
}
</pre>
</div>
</li>
<li>这里的c对应公式 $$P(Y_{i-1}=y_{i-1}, Y_{i}=y_{i}|x)=\frac{\alpha_{i-1}^{T}(y_{i-1}|x)M_{i}(y_{i-1},y_{i}|x)\beta_{i}(y_{i}|x)}{Z(x)}$$
</li>
<li>&alpha; 就对应 <code>lnode-&gt;alpha</code>
</li>
<li>&beta; 对应 <code>rnode-&gt;beta-rnode-&gt;cost</code> ,这里需要注意，要减去这个cost
</li>
<li>M就对应边和点的cost和， <code>cost + rnode-&gt;cost</code>
</li>
<li>两个 <code>rnode-&gt;cost</code> 相互抵消，但是千万不要以为可以直接对应到公式
</li>
<li>bigram,边，转移特征函数的期望计算类似Node的
</li>
</ul>
</li>
</ol>
</div>
</li>
<li><a id="sec-2-3-1-4" name="sec-2-3-1-4"></a>减去经验期望<br  /><div class="outline-text-5" id="text-2-3-1-4">
<ol class="org-ol">
<li>代码如下
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">size_t</span> <span style="color: #FF8C00;">i</span> = 0;   i &lt; x_.size(); ++i) {
  <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">int</span> *<span style="color: #FF8C00;">f</span> = node_[i][answer_[i]]-&gt;fvector; *f != -1; ++f)
    --expected[*f + answer_[i]];
  s += node_[i][answer_[i]]-&gt;cost;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">UNIGRAM cost</span>
  <span style="color: #FF1493;">const</span> <span style="color: #AF87FF;">std</span>::<span style="color: #5FD7FF; font-style: italic;">vector</span>&lt;<span style="color: #5FD7FF; font-style: italic;">Path</span> *&gt; &amp;<span style="color: #FF8C00;">lpath</span> = node_[i][answer_[i]]-&gt;lpath;
  <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">const_Path_iterator</span> <span style="color: #FF8C00;">it</span> = lpath.begin(); it != lpath.end(); ++it) {
    <span style="color: #FF1493;">if</span> ((*it)-&gt;lnode-&gt;y == answer_[(*it)-&gt;lnode-&gt;x]) {
      <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">int</span> *<span style="color: #FF8C00;">f</span> = (*it)-&gt;fvector; *f != -1; ++f)
        --expected[*f +(*it)-&gt;lnode-&gt;y * ysize_ +(*it)-&gt;rnode-&gt;y];
      s += (*it)-&gt;cost;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">BIGRAM COST</span>
      <span style="color: #FF1493;">break</span>;
    }
  }
}
</pre>
</div>
</li>
<li>answer里面存放了该行的label值
</li>
<li>样本总是认为是正确的，故函数在取值为answer的经验期望就是1。固有 <code>--expected</code>
</li>
<li>s是未归一化的经验概率，最后返回Z_ - s， <code>s-Z_</code> 的值就是下面的最大似然估计的损失函数，这里算 <code>Z_ - s</code> 其实是让损失函数最小化，同时，对应的梯度也取了负号
<ul class="org-ul">
<li>本来损失函数是 \(log(exp(s)/exp(Z))=s-Z\)
</li>
<li>其实返回的损失函数是\(log(exp(Z_)/exp(s))=Z_-s\)
</li>
</ul>
</li>
<li>这里是excepted是条件期望减去经验期望，正好对应上面对损失函数加了个负号
</li>
<li>经验期望减去条件期望就是梯度的证明如下：
<ul class="org-ul">
<li>给定x条件，y的条件概率 $$P(y|x)=\frac{1}{Z(x)}exp(\sum_{i=1}^{N}\sum_{t=1}^{T}\sum_{k=1}^{K}\lambda_{k}f_{k}(y_{t},y_{t-1},x_{t}))$$
</li>
<li>\(假设样本为x_{i}, y_{i}\)
</li>
<li>极大似然估计 $$l(\theta)=\sum_{i=1}^{N}log p(y_{i}|x_{i})$$
</li>
<li>$$l(\theta)=\sum_{i=1}^{N}\sum_{t=1}^{T}\sum_{k=1}^{K}\lambda_{k}f_{k}(y_{t}^{(i)},y_{t-1}^{(i)},x_{t}^{(i)})-\sum_{i=1}^{N}log Z(x^{(i)})$$
</li>
<li>$$g(\lambda_{k})=\sum_{i=1}^{N}\sum_{t=1}^{T}f_{k}(y_{t}^{(i)},y_{t-1}^{(i)},x_{t}^{(i)}) - \sum_{i=1}^{N}\sum_{t=1}^{T}\sum_{y,y'}\frac{1}{Z(x^{(i)})}exp(\sum_{k=1}^{K}\lambda_{k}f(y,y',x_{t}^{(i)})f(y,y',x_{t}^{(i)})$$
</li>
<li>$$g(\lambda_{k})=\sum_{i=1}^{N}\sum_{t=1}^{T}f_{k}(y_{t}^{(i)},y_{t-1}^{(i)},x_{t}^{(i)}) - \sum_{i=1}^{N}\sum_{t=1}^{T}\sum_{y,y'}p(y,y',x_{t}^{(i)})f(y,y',x_{t}^{(i)})$$
</li>
</ul>
</li>
<li>前一项就是经验期望，后一项就是条件期望
</li>
</ol>
</div>
</li>

<li><a id="sec-2-3-1-5" name="sec-2-3-1-5"></a>viterbi<br  /><div class="outline-text-5" id="text-2-3-1-5">
<ol class="org-ol">
<li>代码如下
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #5FD7FF; font-style: italic;">void</span> <span style="color: #AF87FF;">TaggerImpl</span>::<span style="color: #87D700;">viterbi</span>() {
  <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">size_t</span> <span style="color: #FF8C00;">i</span> = 0;   i &lt; x_.size(); ++i) {
    <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">size_t</span> <span style="color: #FF8C00;">j</span> = 0; j &lt; ysize_; ++j) {
      <span style="color: #5FD7FF; font-style: italic;">double</span> <span style="color: #FF8C00;">bestc</span> = -1e37;
      <span style="color: #5FD7FF; font-style: italic;">Node</span> *<span style="color: #FF8C00;">best</span> = 0;
      <span style="color: #FF1493;">const</span> <span style="color: #AF87FF;">std</span>::<span style="color: #5FD7FF; font-style: italic;">vector</span>&lt;<span style="color: #5FD7FF; font-style: italic;">Path</span> *&gt; &amp;<span style="color: #FF8C00;">lpath</span> = node_[i][j]-&gt;lpath;
      <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">const_Path_iterator</span> <span style="color: #FF8C00;">it</span> = lpath.begin(); it != lpath.end(); ++it) {
        <span style="color: #5FD7FF; font-style: italic;">double</span> <span style="color: #FF8C00;">cost</span> = (*it)-&gt;lnode-&gt;bestCost +(*it)-&gt;cost +
            node_[i][j]-&gt;cost;
        <span style="color: #FF1493;">if</span> (cost &gt; bestc) {
          bestc = cost;
          best  = (*it)-&gt;lnode;
        }
      }
      node_[i][j]-&gt;prev     = best;
      node_[i][j]-&gt;bestCost = best ? bestc : node_[i][j]-&gt;cost;
    }
  }

  <span style="color: #5FD7FF; font-style: italic;">double</span> <span style="color: #FF8C00;">bestc</span> = -1e37;
  <span style="color: #5FD7FF; font-style: italic;">Node</span> *<span style="color: #FF8C00;">best</span> = 0;
  <span style="color: #5FD7FF; font-style: italic;">size_t</span> <span style="color: #FF8C00;">s</span> = x_.size()-1;
  <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">size_t</span> <span style="color: #FF8C00;">j</span> = 0; j &lt; ysize_; ++j) {
    <span style="color: #FF1493;">if</span> (bestc &lt; node_[s][j]-&gt;bestCost) {
      best  = node_[s][j];
      bestc = node_[s][j]-&gt;bestCost;
    }
  }

  <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF; font-style: italic;">Node</span> *<span style="color: #FF8C00;">n</span> = best; n; n = n-&gt;prev)
    result_[n-&gt;x] = n-&gt;y;

  cost_ = -node_[x_.size()-1][result_[x_.size()-1]]-&gt;bestCost;
}
</pre>
</div>
</li>
<li>动态规划找了条概率最大的路径
</li>
</ol>
</div>
</li>

<li><a id="sec-2-3-1-6" name="sec-2-3-1-6"></a>正则化<br  /></li></ol>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 预测</h3>
<div class="outline-text-3" id="text-2-4">
<ol class="org-ol">
<li>代码如下
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #5FD7FF; font-style: italic;">bool</span> <span style="color: #AF87FF;">TaggerImpl</span>::<span style="color: #87D700;">parse</span>() {
  CHECK_FALSE(feature_index_-&gt;buildFeatures(<span style="color: #FF1493;">this</span>))
      &lt;&lt; feature_index_-&gt;what();

  <span style="color: #FF1493;">if</span> (x_.empty()) <span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">true</span>;
  buildLattice();
  <span style="color: #FF1493;">if</span> (nbest_ || vlevel_ &gt;= 1) forwardbackward();
  viterbi();
  <span style="color: #FF1493;">if</span> (nbest_) initNbest();

  <span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">true</span>;
}
</pre>
</div>
</li>
<li></li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Chao Huang</p>
<p class="date">Created: 2018-01-03 三 11:48</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"></p>
</div>
</body>
</html>
